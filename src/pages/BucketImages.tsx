import { useState, useEffect } from 'react';
import { useParams, useNavigate } from 'react-router-dom';
import { useQuery } from '@tanstack/react-query';
import api from '../services/api';
import { useAuthStore } from '../store/authStore';
import ImageEditor from '../components/ImageEditor';
import './BucketImages.css';

interface Image {
  id: number;
  file_path: string;
  source_url: string;
}

interface BucketImage {
  id: number;
  friendly_name: string;
  description: string;
  twitter_description: string;
  force_send_date: string | null;
  repeat: boolean;
  post_to: number;
  use_watermark: boolean;
  image: Image;
  created_at: string;
  updated_at: string;
}

interface Bucket {
  id: number;
  name: string;
  description: string;
  use_watermark: boolean;
  post_once_bucket: boolean;
  is_global?: boolean;
  images_count: number;
  schedules_count: number;
}

export default function BucketImages() {
  const { bucketId } = useParams<{ bucketId: string }>();
  const navigate = useNavigate();
  const user = useAuthStore((state) => state.user);
  const isSuperAdmin = user?.super_admin || false;
  const [bucket, setBucket] = useState<Bucket | null>(null);
  const [images, setImages] = useState<BucketImage[]>([]);
  const [loading, setLoading] = useState(true);
  const [uploading, setUploading] = useState(false);
  const [selectedFile, setSelectedFile] = useState<File | null>(null);
  const [previewUrl, setPreviewUrl] = useState<string | null>(null);
  const [error, setError] = useState('');
  const [success, setSuccess] = useState('');
  const [editingImage, setEditingImage] = useState<BucketImage | null>(null);
  
  // Fetch user info for watermark logo
  const { data: userData } = useQuery({
    queryKey: ['user_info'],
    queryFn: async () => {
      const response = await api.get('/user_info');
      return response.data;
    },
  });
  
  const watermarkLogoUrl = userData?.user?.watermark_logo_url;
  
  // Check if user can modify this bucket (super admin for global buckets, or owner for regular buckets)
  const canModifyBucket = bucket ? (bucket.is_global ? isSuperAdmin : true) : false;

  const getImageUrl = (image: Image, forEditor: boolean = false) => {
    // Always prefer source_url from the API (it's generated by get_source_url)
    if (image?.source_url) {
      // Check if it's a placeholder URL and log a warning
      if (image.source_url.includes('via.placeholder.com')) {
        console.warn('Image has placeholder URL - image may not be accessible:', image);
      }
      
      const sourceUrl = image.source_url;
      console.log('[BucketImages] getImageUrl called:', { sourceUrl, forEditor, image });
      
      // For the image editor, always proxy external URLs to avoid CORS issues
      // The Cropper component needs CORS-enabled images to draw to canvas
      if (forEditor) {
        const backendUrl = import.meta.env.VITE_API_BASE_URL?.replace(/\/api\/v1$/, '') || 
                          'https://new-social-rotation-backend-qzyk8.ondigitalocean.app';
        
        // Check if it's an external URL (starts with http:// or https://)
        const isExternalUrl = sourceUrl.startsWith('http://') || sourceUrl.startsWith('https://');
        // Check if it's already a backend proxy URL (don't double-proxy)
        const isAlreadyProxied = sourceUrl.includes(`${backendUrl}/api/v1/images/proxy`);
        
        console.log('[BucketImages] Proxy check:', { isExternalUrl, isAlreadyProxied, backendUrl });
        
        if (isExternalUrl && !isAlreadyProxied) {
          // External URL - proxy through backend for CORS
          const proxiedUrl = `${backendUrl}/api/v1/images/proxy?url=${encodeURIComponent(sourceUrl)}`;
          console.log('[BucketImages] Proxying external image for editor:', sourceUrl, '->', proxiedUrl);
          return proxiedUrl;
        }
      }
      
      return sourceUrl;
    }

    // Fallback to file_path if it's already a full URL
    if (image?.file_path?.startsWith('http://') || image?.file_path?.startsWith('https://')) {
      return image.file_path;
    }

    // Last resort: construct URL from file_path
    const assetHost =
      import.meta.env.VITE_ASSET_BASE_URL ||
      import.meta.env.VITE_API_BASE_URL?.replace(/\/api\/v1$/, '') ||
      window.location.origin;

    const normalizedPath = image?.file_path?.replace(/^\/+/, '') || '';
    const constructedUrl = `${assetHost.replace(/\/+$/, '')}/${normalizedPath}`;
    
    console.warn('Constructed image URL (may not work):', constructedUrl, 'Image:', image);
    return constructedUrl;
  };

  useEffect(() => {
    fetchBucketAndImages();
  }, [bucketId]);

  // Handle clipboard paste for images (keyboard shortcut)
  useEffect(() => {
    if (!canModifyBucket) return; // Only enable paste if user can modify bucket

    const handlePaste = async (e: ClipboardEvent) => {
      // Don't handle paste if user is typing in an input/textarea
      const target = e.target as HTMLElement;
      if (target.tagName === 'INPUT' || target.tagName === 'TEXTAREA' || target.isContentEditable) {
        return;
      }

      const items = e.clipboardData?.items;
      if (!items) return;

      // Look for image in clipboard
      for (let i = 0; i < items.length; i++) {
        const item = items[i];
        
        // Check if it's an image
        if (item.type.indexOf('image') !== -1) {
          e.preventDefault();
          
          const blob = item.getAsFile();
          if (!blob) continue;

          // Validate file size (max 10MB for pasted images)
          if (blob.size > 10 * 1024 * 1024) {
            setError('Pasted image is too large (max 10MB)');
            return;
          }

          // Convert blob to File with a default name
          const fileName = `pasted-image-${Date.now()}.${blob.type.split('/')[1] || 'png'}`;
          const file = new File([blob], fileName, { type: blob.type });

          // Set as selected file (this will trigger preview and allow upload)
          setSelectedFile(file);
          setError('');
          setSuccess('Image pasted! Click Upload to add it to the bucket.');

          // Create preview
          const reader = new FileReader();
          reader.onloadend = () => {
            setPreviewUrl(reader.result as string);
          };
          reader.readAsDataURL(file);
          
          break; // Only handle first image
        }
      }
    };

    // Add paste event listener to window (for Ctrl+V / Cmd+V)
    window.addEventListener('paste', handlePaste);

    return () => {
      window.removeEventListener('paste', handlePaste);
    };
  }, [canModifyBucket]);

  // Helper function to handle paste from clipboard
  const handlePasteClick = async () => {
    try {
      // Request clipboard read permission and get image
      const clipboardItems = await navigator.clipboard.read();
      
      for (const item of clipboardItems) {
        // Check if clipboard contains image
        if (item.types.some(type => type.startsWith('image/'))) {
          const imageType = item.types.find(type => type.startsWith('image/')) || 'image/png';
          const blob = await item.getType(imageType);
          
          if (!blob) continue;

          // Validate file size (max 10MB for pasted images)
          if (blob.size > 10 * 1024 * 1024) {
            setError('Pasted image is too large (max 10MB)');
            return;
          }

          // Convert blob to File with a default name
          const fileName = `pasted-image-${Date.now()}.${imageType.split('/')[1] || 'png'}`;
          const file = new File([blob], fileName, { type: imageType });

          // Set as selected file (this will trigger preview and allow upload)
          setSelectedFile(file);
          setError('');
          setSuccess('Image pasted! Click Upload to add it to the bucket.');

          // Create preview
          const reader = new FileReader();
          reader.onloadend = () => {
            setPreviewUrl(reader.result as string);
          };
          reader.readAsDataURL(file);
          
          return; // Only handle first image
        }
      }
      
      setError('No image found in clipboard. Copy an image first (Ctrl+C / Cmd+C).');
    } catch (err: any) {
      console.error('Error reading clipboard:', err);
      // Fallback: try the old clipboard API via paste event
      setError('Could not read clipboard. Try using Ctrl+V / Cmd+V to paste, or use the file upload button.');
    }
  };

  const fetchBucketAndImages = async () => {
    try {
      setLoading(true);
      setError('');
      
      // Fetch bucket details
      const bucketResponse = await api.get(`/buckets/${bucketId}`);
      setBucket(bucketResponse.data.bucket);
      setImages(bucketResponse.data.bucket_images || []);
    } catch (err: any) {
      console.error('Error fetching bucket:', err);
      setError(err.response?.data?.error || 'Failed to load bucket');
    } finally {
      setLoading(false);
    }
  };

  const handleFileSelect = (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (file) {
      const fileName = file.name.toLowerCase();
      const isZip = fileName.endsWith('.zip');
      const isImage = file.type.startsWith('image/');
      
      // Validate file type - accept images or ZIP files
      if (!isImage && !isZip) {
        setError('Please select an image file or ZIP file');
        return;
      }
      
      // Validate file size
      if (isZip) {
        // Max 50MB for ZIP files
        if (file.size > 50 * 1024 * 1024) {
          setError('ZIP file size must be less than 50MB');
          return;
        }
      } else {
        // Max 10MB for individual images
        if (file.size > 10 * 1024 * 1024) {
          setError('File size must be less than 10MB');
          return;
        }
      }
      
      setSelectedFile(file);
      setError('');
      
      // Create preview only for images (not ZIP files)
      if (isImage) {
        const reader = new FileReader();
        reader.onloadend = () => {
          setPreviewUrl(reader.result as string);
        };
        reader.readAsDataURL(file);
      } else {
        setPreviewUrl(null);
      }
    }
  };

  const handleUpload = async () => {
    if (!selectedFile) {
      setError('Please select a file to upload');
      return;
    }

    try {
      setUploading(true);
      setError('');
      setSuccess('');

      const formData = new FormData();
      formData.append('file', selectedFile);

      const response = await api.post(
        `/buckets/${bucketId}/images/upload`,
        formData,
        {
          headers: {
            'Content-Type': 'multipart/form-data',
          },
        }
      );

      const data = response.data;
      const isZip = selectedFile.name.toLowerCase().endsWith('.zip');
      
      // Handle response - could be single image or multiple from ZIP
      if (isZip && data.bucket_images) {
        const uploadedCount = data.uploaded_count || data.bucket_images.length;
        let successMsg = `Successfully uploaded ${uploadedCount} image${uploadedCount !== 1 ? 's' : ''} from ZIP file`;
        
        if (data.errors && data.errors.length > 0) {
          successMsg += ` (${data.errors.length} file${data.errors.length !== 1 ? 's' : ''} skipped)`;
          console.warn('Upload warnings:', data.errors);
        }
        
        setSuccess(successMsg);
      } else {
        setSuccess('Image uploaded successfully!');
      }
      
      setSelectedFile(null);
      setPreviewUrl(null);
      
      // Refresh the images list
      await fetchBucketAndImages();
      
      // Clear success message after 5 seconds (longer for ZIP uploads)
      setTimeout(() => setSuccess(''), 5000);
    } catch (err: any) {
      console.error('Error uploading file:', err);
      const errorMsg = err.response?.data?.error || 
                      (err.response?.data?.errors && Array.isArray(err.response.data.errors) 
                        ? err.response.data.errors.join(', ') 
                        : 'Failed to upload file');
      setError(errorMsg);
    } finally {
      setUploading(false);
    }
  };

  const handleDelete = async (imageId: number) => {
    if (!window.confirm('Are you sure you want to delete this image?')) {
      return;
    }

    try {
      await api.delete(`/buckets/${bucketId}/images/${imageId}`);
      setSuccess('Image deleted successfully!');
      
      // Refresh the images list
      await fetchBucketAndImages();
      
      // Clear success message after 3 seconds
      setTimeout(() => setSuccess(''), 3000);
    } catch (err: any) {
      console.error('Error deleting image:', err);
      setError(err.response?.data?.error || 'Failed to delete image');
    }
  };

  const cancelUpload = () => {
    setSelectedFile(null);
    setPreviewUrl(null);
    setError('');
  };

  const handleEdit = (bucketImage: BucketImage) => {
    // Check if image is broken (no source_url or placeholder URL)
    const latestImage = images.find(img => img.id === bucketImage.id) || bucketImage;
    const imageUrl = latestImage?.image?.source_url || latestImage?.image?.file_path || '';
    
    if (!imageUrl || imageUrl.includes('via.placeholder.com') || imageUrl.includes('placeholder/')) {
      setError('Cannot edit this image - image file is missing or broken. Please delete and re-upload.');
      return;
    }
    
    // Always use the latest image data from the images state
    // This ensures we're editing the most recent version (including after edits)
    setEditingImage(latestImage);
  };


  if (loading) {
    return (
      <div className="bucket-images-page">
        <div className="loading">Loading...</div>
      </div>
    );
  }

  if (!bucket) {
    return (
      <div className="bucket-images-page">
        <div className="error">Bucket not found</div>
      </div>
    );
  }

  return (
    <div className="bucket-images-page">
      <div className="page-header">
        <button className="back-button" onClick={() => navigate('/buckets')}>
          ‚Üê Back to Buckets
        </button>
        <div style={{ display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
          <h1>{bucket.name}</h1>
          {bucket.is_global && (
            <span className="global-badge" title="Global bucket - available to all users" style={{ fontSize: '1.25rem' }}>üåê</span>
          )}
        </div>
        {bucket.description && <p className="bucket-description">{bucket.description}</p>}
        {bucket.is_global && !isSuperAdmin && (
          <p style={{ fontSize: '0.9rem', color: '#666', fontStyle: 'italic', marginTop: '0.5rem' }}>
            This is a global bucket. Only super admins can modify it.
          </p>
        )}
      </div>

      {error && <div className="error-message">{error}</div>}
      {success && <div className="success-message">{success}</div>}

      {/* Upload Section - Only show if user can modify bucket */}
      {canModifyBucket && (
      <div className="upload-section">
        <h2>Upload Images</h2>
        <p style={{ fontSize: '0.9rem', color: '#666', marginBottom: '1rem' }}>
          Upload a single image file or a ZIP file containing multiple images (max 50MB for ZIP, 10MB per image)
        </p>
        <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '1rem', marginBottom: '1rem' }}>
          {/* File Upload */}
          <div className="upload-container">
          {!selectedFile ? (
            <div className="file-input-wrapper">
              <input
                type="file"
                id="file-input"
                accept="image/*,.zip"
                onChange={handleFileSelect}
                className="file-input"
              />
              <label htmlFor="file-input" className="file-input-label">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor">
                  <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4" />
                  <polyline points="17 8 12 3 7 8" />
                  <line x1="12" y1="3" x2="12" y2="15" />
                </svg>
                Choose Image or ZIP File
              </label>
            </div>
          ) : (
            <div className="upload-preview">
              {previewUrl && <img src={previewUrl} alt="Preview" className="preview-image" />}
              <div className="upload-actions">
                <p className="file-name">
                  {selectedFile.name}
                  {selectedFile.name.toLowerCase().endsWith('.zip') && (
                    <span style={{ display: 'block', fontSize: '0.85rem', color: '#666', marginTop: '0.25rem' }}>
                      ZIP file - will extract and upload all images
                    </span>
                  )}
                </p>
                <div className="button-group">
                  <button
                    onClick={handleUpload}
                    disabled={uploading}
                    className="btn-upload"
                  >
                    {uploading ? 'Uploading...' : 'Upload'}
                  </button>
                  <button
                    onClick={cancelUpload}
                    disabled={uploading}
                    className="btn-cancel"
                  >
                    Cancel
                  </button>
                </div>
              </div>
            </div>
          )}
          </div>

          {/* Paste Upload */}
          <div className="upload-container">
            <div className="file-input-wrapper">
              <button
                type="button"
                onClick={handlePasteClick}
                className="file-input-label"
                style={{ 
                  width: '100%', 
                  cursor: 'pointer',
                  display: 'flex',
                  flexDirection: 'column',
                  alignItems: 'center',
                  justifyContent: 'center',
                  gap: '0.5rem',
                  padding: '2rem',
                  border: '2px dashed #007bff',
                  borderRadius: '8px',
                  backgroundColor: '#f8f9fa',
                  transition: 'all 0.2s'
                }}
                onMouseEnter={(e) => {
                  e.currentTarget.style.backgroundColor = '#e7f3ff';
                  e.currentTarget.style.borderColor = '#0056b3';
                }}
                onMouseLeave={(e) => {
                  e.currentTarget.style.backgroundColor = '#f8f9fa';
                  e.currentTarget.style.borderColor = '#007bff';
                }}
              >
                <svg width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                  <path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2" />
                  <rect x="8" y="2" width="8" height="4" rx="1" ry="1" />
                </svg>
                <span style={{ fontSize: '0.9rem', fontWeight: '500' }}>Paste Image</span>
                <span style={{ fontSize: '0.75rem', color: '#666' }}>Click to paste from clipboard</span>
              </button>
            </div>
          </div>
        </div>
      </div>
      )}

      {/* Images Grid */}
      <div className="images-section">
        <h2>Images ({images.length})</h2>
        {images.length === 0 ? (
          <div className="no-images">
            <p>No images in this bucket yet. Upload your first image above!</p>
          </div>
        ) : (
          <div className="images-grid">
            {images.map((bucketImage) => (
              <div key={bucketImage.id} className="image-card">
                <div className="image-wrapper">
                  <img
                    src={getImageUrl(bucketImage.image)}
                    alt={bucketImage.friendly_name}
                    className="image-thumbnail"
                  />
                </div>
                <div className="image-info">
                  <h3 className="image-name">{bucketImage.friendly_name}</h3>
                  {bucketImage.description && (
                    <p className="image-description">{bucketImage.description}</p>
                  )}
                  {canModifyBucket && (
                  <div className="image-actions">
                    <button
                      onClick={() => handleEdit(bucketImage)}
                      className="btn-edit"
                    >
                      <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                        <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path>
                        <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path>
                      </svg>
                      Edit Image
                    </button>
                    <button
                      onClick={() => handleDelete(bucketImage.id)}
                      className="btn-delete"
                    >
                      <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                        <polyline points="3 6 5 6 21 6"></polyline>
                        <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
                      </svg>
                      Delete
                    </button>
                  </div>
                  )}
                </div>
              </div>
            ))}
          </div>
        )}
      </div>

      {/* Image Editor Modal */}
      {editingImage && (() => {
        // Always proxy external URLs for the editor to avoid CORS issues
        const editorImageUrl = (() => {
          const url = getImageUrl(editingImage.image, true);
          console.log('[BucketImages] Editor image URL (before final check):', url);
          
          // Double-check: if it's an external URL and not already proxied, force proxy
          if (url && (url.startsWith('http://') || url.startsWith('https://'))) {
            const backendUrl = import.meta.env.VITE_API_BASE_URL?.replace(/\/api\/v1$/, '') || 
                              'https://new-social-rotation-backend-qzyk8.ondigitalocean.app';
            
            if (!url.includes(`${backendUrl}/api/v1/images/proxy`)) {
              const proxiedUrl = `${backendUrl}/api/v1/images/proxy?url=${encodeURIComponent(url)}`;
              console.log('[BucketImages] FORCING proxy for editor:', url.substring(0, 60) + '...', '->', proxiedUrl.substring(0, 60) + '...');
              return proxiedUrl;
            }
          }
          return url;
        })();
        
        return (
        <ImageEditor
          imageUrl={editorImageUrl}
          imageName={editingImage.friendly_name}
          watermarkLogoUrl={watermarkLogoUrl}
          onClose={() => setEditingImage(null)}
          onSave={async (editedBlob, newName) => {
            try {
              // Ensure the blob has a proper filename with extension
              // Extract extension from original image URL or default to .jpg
              const originalImage = editingImage?.image;
              const originalUrl = originalImage?.file_path || originalImage?.source_url || '';
              let extension = '.jpg'; // Default to .jpg
              
              if (originalUrl) {
                // Try to extract extension from URL
                const urlMatch = originalUrl.match(/\.(jpg|jpeg|png|gif|webp)(\?|$)/i);
                if (urlMatch) {
                  extension = urlMatch[1].toLowerCase();
                  if (extension === 'jpeg') extension = 'jpg';
                  extension = `.${extension}`;
                }
              }
              
              // Create File object with proper name and extension
              const fileName = `${newName || editingImage.friendly_name || 'edited-image'}${extension}`;
              const file = new File([editedBlob], fileName, { 
                type: editedBlob.type || 'image/jpeg' 
              });
              
              const formData = new FormData();
              formData.append('file', file);
              
              await api.patch(
                `/buckets/${bucketId}/images/${editingImage.id}`,
                formData,
                {
                  headers: {
                    'Content-Type': 'multipart/form-data',
                  },
                }
              );
              
              // Refresh images to get the updated image with new URL
              // This ensures the edited image URL is loaded when editing again
              await fetchBucketAndImages();
              
              setEditingImage(null);
            } catch (err: any) {
              console.error('Error saving edited image:', err);
            }
          }}
        />
        );
      })()}
    </div>
  );
}

