import { useState, useEffect } from 'react';
import { useParams, useNavigate } from 'react-router-dom';
import api from '../services/api';
import { useAuthStore } from '../store/authStore';
import ImageEditor from '../components/ImageEditor';
import './BucketImages.css';

interface Image {
  id: number;
  file_path: string;
  source_url: string;
}

interface BucketImage {
  id: number;
  friendly_name: string;
  description: string;
  twitter_description: string;
  force_send_date: string | null;
  repeat: boolean;
  post_to: number;
  use_watermark: boolean;
  image: Image;
  created_at: string;
  updated_at: string;
}

interface Bucket {
  id: number;
  name: string;
  description: string;
  use_watermark: boolean;
  post_once_bucket: boolean;
  is_global?: boolean;
  images_count: number;
  schedules_count: number;
}

export default function BucketImages() {
  const { bucketId } = useParams<{ bucketId: string }>();
  const navigate = useNavigate();
  const user = useAuthStore((state) => state.user);
  const isSuperAdmin = user?.super_admin || false;
  const [bucket, setBucket] = useState<Bucket | null>(null);
  const [images, setImages] = useState<BucketImage[]>([]);
  const [loading, setLoading] = useState(true);
  const [uploading, setUploading] = useState(false);
  const [selectedFile, setSelectedFile] = useState<File | null>(null);
  const [previewUrl, setPreviewUrl] = useState<string | null>(null);
  const [error, setError] = useState('');
  const [success, setSuccess] = useState('');
  const [editingImage, setEditingImage] = useState<BucketImage | null>(null);
  
  // Check if user can modify this bucket (super admin for global buckets, or owner for regular buckets)
  const canModifyBucket = bucket ? (bucket.is_global ? isSuperAdmin : true) : false;

  const getImageUrl = (image: Image) => {
    // Always prefer source_url from the API (it's generated by get_source_url)
    if (image?.source_url) {
      // Check if it's a placeholder URL and log a warning
      if (image.source_url.includes('via.placeholder.com')) {
        console.warn('Image has placeholder URL - image may not be accessible:', image);
      }
      
      // For external URLs (not from our backend), proxy through backend to avoid CORS issues
      // This is especially important for the image editor which uses canvas
      const sourceUrl = image.source_url;
      if (sourceUrl.startsWith('http://') || sourceUrl.startsWith('https://')) {
        // Check if it's already a backend URL (don't double-proxy)
        const backendUrl = import.meta.env.VITE_API_BASE_URL?.replace(/\/api\/v1$/, '') || 
                          'https://new-social-rotation-backend-qzyk8.ondigitalocean.app';
        if (!sourceUrl.includes(backendUrl)) {
          // External URL - proxy through backend for CORS
          return `${backendUrl}/api/v1/images/proxy?url=${encodeURIComponent(sourceUrl)}`;
        }
      }
      
      return sourceUrl;
    }

    // Fallback to file_path if it's already a full URL
    if (image?.file_path?.startsWith('http://') || image?.file_path?.startsWith('https://')) {
      return image.file_path;
    }

    // Last resort: construct URL from file_path
    const assetHost =
      import.meta.env.VITE_ASSET_BASE_URL ||
      import.meta.env.VITE_API_BASE_URL?.replace(/\/api\/v1$/, '') ||
      window.location.origin;

    const normalizedPath = image?.file_path?.replace(/^\/+/, '') || '';
    const constructedUrl = `${assetHost.replace(/\/+$/, '')}/${normalizedPath}`;
    
    console.warn('Constructed image URL (may not work):', constructedUrl, 'Image:', image);
    return constructedUrl;
  };

  useEffect(() => {
    fetchBucketAndImages();
  }, [bucketId]);

  const fetchBucketAndImages = async () => {
    try {
      setLoading(true);
      setError('');
      
      // Fetch bucket details
      const bucketResponse = await api.get(`/buckets/${bucketId}`);
      setBucket(bucketResponse.data.bucket);
      setImages(bucketResponse.data.bucket_images || []);
    } catch (err: any) {
      console.error('Error fetching bucket:', err);
      setError(err.response?.data?.error || 'Failed to load bucket');
    } finally {
      setLoading(false);
    }
  };

  const handleFileSelect = (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (file) {
      const fileName = file.name.toLowerCase();
      const isZip = fileName.endsWith('.zip');
      const isImage = file.type.startsWith('image/');
      
      // Validate file type - accept images or ZIP files
      if (!isImage && !isZip) {
        setError('Please select an image file or ZIP file');
        return;
      }
      
      // Validate file size
      if (isZip) {
        // Max 50MB for ZIP files
        if (file.size > 50 * 1024 * 1024) {
          setError('ZIP file size must be less than 50MB');
          return;
        }
      } else {
        // Max 10MB for individual images
        if (file.size > 10 * 1024 * 1024) {
          setError('File size must be less than 10MB');
          return;
        }
      }
      
      setSelectedFile(file);
      setError('');
      
      // Create preview only for images (not ZIP files)
      if (isImage) {
        const reader = new FileReader();
        reader.onloadend = () => {
          setPreviewUrl(reader.result as string);
        };
        reader.readAsDataURL(file);
      } else {
        setPreviewUrl(null);
      }
    }
  };

  const handleUpload = async () => {
    if (!selectedFile) {
      setError('Please select a file to upload');
      return;
    }

    try {
      setUploading(true);
      setError('');
      setSuccess('');

      const formData = new FormData();
      formData.append('file', selectedFile);

      const response = await api.post(
        `/buckets/${bucketId}/images/upload`,
        formData,
        {
          headers: {
            'Content-Type': 'multipart/form-data',
          },
        }
      );

      const data = response.data;
      const isZip = selectedFile.name.toLowerCase().endsWith('.zip');
      
      // Handle response - could be single image or multiple from ZIP
      if (isZip && data.bucket_images) {
        const uploadedCount = data.uploaded_count || data.bucket_images.length;
        let successMsg = `Successfully uploaded ${uploadedCount} image${uploadedCount !== 1 ? 's' : ''} from ZIP file`;
        
        if (data.errors && data.errors.length > 0) {
          successMsg += ` (${data.errors.length} file${data.errors.length !== 1 ? 's' : ''} skipped)`;
          console.warn('Upload warnings:', data.errors);
        }
        
        setSuccess(successMsg);
      } else {
        setSuccess('Image uploaded successfully!');
      }
      
      setSelectedFile(null);
      setPreviewUrl(null);
      
      // Refresh the images list
      await fetchBucketAndImages();
      
      // Clear success message after 5 seconds (longer for ZIP uploads)
      setTimeout(() => setSuccess(''), 5000);
    } catch (err: any) {
      console.error('Error uploading file:', err);
      const errorMsg = err.response?.data?.error || 
                      (err.response?.data?.errors && Array.isArray(err.response.data.errors) 
                        ? err.response.data.errors.join(', ') 
                        : 'Failed to upload file');
      setError(errorMsg);
    } finally {
      setUploading(false);
    }
  };

  const handleDelete = async (imageId: number) => {
    if (!window.confirm('Are you sure you want to delete this image?')) {
      return;
    }

    try {
      await api.delete(`/buckets/${bucketId}/images/${imageId}`);
      setSuccess('Image deleted successfully!');
      
      // Refresh the images list
      await fetchBucketAndImages();
      
      // Clear success message after 3 seconds
      setTimeout(() => setSuccess(''), 3000);
    } catch (err: any) {
      console.error('Error deleting image:', err);
      setError(err.response?.data?.error || 'Failed to delete image');
    }
  };

  const cancelUpload = () => {
    setSelectedFile(null);
    setPreviewUrl(null);
    setError('');
  };

  const handleEdit = (bucketImage: BucketImage) => {
    // Always use the latest image data from the images state
    // This ensures we're editing the most recent version (including after edits)
    const latestImage = images.find(img => img.id === bucketImage.id) || bucketImage;
    setEditingImage(latestImage);
  };


  if (loading) {
    return (
      <div className="bucket-images-page">
        <div className="loading">Loading...</div>
      </div>
    );
  }

  if (!bucket) {
    return (
      <div className="bucket-images-page">
        <div className="error">Bucket not found</div>
      </div>
    );
  }

  return (
    <div className="bucket-images-page">
      <div className="page-header">
        <button className="back-button" onClick={() => navigate('/buckets')}>
          ‚Üê Back to Buckets
        </button>
        <div style={{ display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
          <h1>{bucket.name}</h1>
          {bucket.is_global && (
            <span className="global-badge" title="Global bucket - available to all users" style={{ fontSize: '1.25rem' }}>üåê</span>
          )}
        </div>
        {bucket.description && <p className="bucket-description">{bucket.description}</p>}
        {bucket.is_global && !isSuperAdmin && (
          <p style={{ fontSize: '0.9rem', color: '#666', fontStyle: 'italic', marginTop: '0.5rem' }}>
            This is a global bucket. Only super admins can modify it.
          </p>
        )}
      </div>

      {error && <div className="error-message">{error}</div>}
      {success && <div className="success-message">{success}</div>}

      {/* Upload Section - Only show if user can modify bucket */}
      {canModifyBucket && (
      <div className="upload-section">
        <h2>Upload Images</h2>
        <p style={{ fontSize: '0.9rem', color: '#666', marginBottom: '1rem' }}>
          Upload a single image file or a ZIP file containing multiple images (max 50MB for ZIP, 10MB per image)
        </p>
        <div className="upload-container">
          {!selectedFile ? (
            <div className="file-input-wrapper">
              <input
                type="file"
                id="file-input"
                accept="image/*,.zip"
                onChange={handleFileSelect}
                className="file-input"
              />
              <label htmlFor="file-input" className="file-input-label">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor">
                  <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4" />
                  <polyline points="17 8 12 3 7 8" />
                  <line x1="12" y1="3" x2="12" y2="15" />
                </svg>
                Choose Image or ZIP File
              </label>
            </div>
          ) : (
            <div className="upload-preview">
              {previewUrl && <img src={previewUrl} alt="Preview" className="preview-image" />}
              <div className="upload-actions">
                <p className="file-name">
                  {selectedFile.name}
                  {selectedFile.name.toLowerCase().endsWith('.zip') && (
                    <span style={{ display: 'block', fontSize: '0.85rem', color: '#666', marginTop: '0.25rem' }}>
                      ZIP file - will extract and upload all images
                    </span>
                  )}
                </p>
                <div className="button-group">
                  <button
                    onClick={handleUpload}
                    disabled={uploading}
                    className="btn-upload"
                  >
                    {uploading ? 'Uploading...' : 'Upload'}
                  </button>
                  <button
                    onClick={cancelUpload}
                    disabled={uploading}
                    className="btn-cancel"
                  >
                    Cancel
                  </button>
                </div>
              </div>
            </div>
          )}
        </div>
      </div>
      )}

      {/* Images Grid */}
      <div className="images-section">
        <h2>Images ({images.length})</h2>
        {images.length === 0 ? (
          <div className="no-images">
            <p>No images in this bucket yet. Upload your first image above!</p>
          </div>
        ) : (
          <div className="images-grid">
            {images.map((bucketImage) => (
              <div key={bucketImage.id} className="image-card">
                <div className="image-wrapper">
                  <img
                    src={getImageUrl(bucketImage.image)}
                    alt={bucketImage.friendly_name}
                    className="image-thumbnail"
                  />
                </div>
                <div className="image-info">
                  <h3 className="image-name">{bucketImage.friendly_name}</h3>
                  {bucketImage.description && (
                    <p className="image-description">{bucketImage.description}</p>
                  )}
                  {canModifyBucket && (
                  <div className="image-actions">
                    <button
                      onClick={() => handleEdit(bucketImage)}
                      className="btn-edit"
                    >
                      <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                        <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path>
                        <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path>
                      </svg>
                      Edit Image
                    </button>
                    <button
                      onClick={() => handleDelete(bucketImage.id)}
                      className="btn-delete"
                    >
                      <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                        <polyline points="3 6 5 6 21 6"></polyline>
                        <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
                      </svg>
                      Delete
                    </button>
                  </div>
                  )}
                </div>
              </div>
            ))}
          </div>
        )}
      </div>

      {/* Image Editor Modal */}
      {editingImage && (
        <ImageEditor
          imageUrl={getImageUrl(editingImage.image)}
          imageName={editingImage.friendly_name}
          onClose={() => setEditingImage(null)}
          onSave={async (editedBlob, newName) => {
            try {
              const formData = new FormData();
              formData.append('file', editedBlob, newName || editingImage.friendly_name);
              
              await api.patch(
                `/buckets/${bucketId}/images/${editingImage.id}`,
                formData,
                {
                  headers: {
                    'Content-Type': 'multipart/form-data',
                  },
                }
              );
              
              // Refresh images to get the updated image with new URL
              // This ensures the edited image URL is loaded when editing again
              await fetchBucketAndImages();
              
              setEditingImage(null);
            } catch (err: any) {
              console.error('Error saving edited image:', err);
            }
          }}
        />
      )}
    </div>
  );
}

